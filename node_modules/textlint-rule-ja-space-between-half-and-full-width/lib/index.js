// LICENSE : MIT
"use strict";

var _textlintRuleHelper = require("textlint-rule-helper");
var _matchIndex = require("match-index");
var _regexpStringMatcher = require("@textlint/regexp-string-matcher");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var assert = require("assert");
/*
 全角文字と半角文字の間にスペースを入れるかどうか
 */

var PunctuationRegExp = /[。、]/;
var ZenRegExpStr = "[、。]|[\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]|[\uD840-\uD87F][\uDC00-\uDFFF]|[ぁ-んァ-ヶ]";
var defaultSpaceOptions = {
  alphabets: false,
  numbers: false,
  punctuation: false
};
var defaultOptions = {
  // プレーンテキスト以外を対象とするか See https://github.com/textlint/textlint-rule-helper#rulehelperisplainstrnodenode-boolean
  lintStyledNode: false,
  /**
   * 例外として無視する文字列
   * RegExp-like Stringの配列を指定
   * https://github.com/textlint/regexp-string-matcher?tab=readme-ov-file#regexp-like-string
   */
  allows: []
};
function reporter(context) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  /**
   * 入力された `space` オプションを内部処理用に成形する
   * @param {string|Array|undefined} opt `space` オプションのインプット
   * @param {boolean|undefined} exceptPunctuation `exceptPunctuation` オプションのインプット
   * @returns {Object}
   */
  var parseSpaceOption = (opt, exceptPunctuation) => {
    if (typeof opt === "string") {
      assert(opt === "always" || opt === "never", "\"space\" options should be \"always\", \"never\" or an array.");
      if (opt === "always") {
        if (exceptPunctuation === false) {
          return _objectSpread(_objectSpread({}, defaultSpaceOptions), {}, {
            alphabets: true,
            numbers: true,
            punctuation: true
          });
        } else {
          return _objectSpread(_objectSpread({}, defaultSpaceOptions), {}, {
            alphabets: true,
            numbers: true
          });
        }
      } else if (opt === "never") {
        if (exceptPunctuation === false) {
          return _objectSpread(_objectSpread({}, defaultSpaceOptions), {}, {
            punctuation: true
          });
        } else {
          return defaultSpaceOptions;
        }
      }
    } else if (Array.isArray(opt)) {
      assert(opt.every(v => Object.keys(defaultSpaceOptions).includes(v)), "Only \"alphabets\", \"numbers\", \"punctuation\" can be included in the array.");
      var userOptions = Object.fromEntries(opt.map(key => [key, true]));
      return _objectSpread(_objectSpread({}, defaultSpaceOptions), userOptions);
    }
    return defaultSpaceOptions;
  };
  var {
    Syntax,
    RuleError,
    report,
    fixer,
    getSource
  } = context;
  var helper = new _textlintRuleHelper.RuleHelper();
  var spaceOption = parseSpaceOption(options.space, options.exceptPunctuation);
  var lintStyledNode = options.lintStyledNode !== undefined ? options.lintStyledNode : defaultOptions.lintStyledNode;
  var allows = options.allows !== undefined ? options.allows : defaultOptions.allows;
  /**
   * `text`を対象に例外オプションを取り除くfilter関数を返す
   * @param {string} text テスト対象のテキスト全体
   * @param {number} padding +1 or -1
   * @returns {function(*, *)}
   */
  var createFilter = (text, padding) => {
    var allowedPatterns = allows.length > 0 ? (0, _regexpStringMatcher.matchPatterns)(text, allows) : [];
    /**
     * `PunctuationRegExp`で指定された例外を取り除く
     * @param {Object} match
     * @returns {boolean}
     */
    return match => {
      var targetChar = text[match.index + padding];
      if (!targetChar) {
        return false;
      }
      if (!spaceOption.punctuation && PunctuationRegExp.test(targetChar)) {
        return false;
      }
      var isAllowed = allowedPatterns.some(allow => {
        // start ... end
        if (allow.startIndex <= match.index && match.index <= allow.endIndex) {
          return true;
        }
        return false;
      });
      return !isAllowed;
    };
  };
  // Never: アルファベットと全角の間はスペースを入れない
  var noSpaceBetween = (node, text) => {
    var betweenHanAndZen = (0, _matchIndex.matchCaptureGroupAll)(text, new RegExp("[A-Za-z0-9]([ \u3000])(?:".concat(ZenRegExpStr, ")")));
    var betweenZenAndHan = (0, _matchIndex.matchCaptureGroupAll)(text, new RegExp("(?:".concat(ZenRegExpStr, ")([ \u3000])[A-Za-z0-9]")));
    var reportMatch = match => {
      var {
        index
      } = match;
      report(node, new RuleError("原則として、全角文字と半角文字の間にスペースを入れません。", {
        index: match.index,
        fix: fixer.replaceTextRange([index, index + 1], "")
      }));
    };
    betweenHanAndZen.filter(createFilter(text, 1)).forEach(reportMatch);
    betweenZenAndHan.filter(createFilter(text, -1)).forEach(reportMatch);
  };

  // Always: アルファベットと全角の間はスペースを入れる
  var needSpaceBetween = (node, text, options) => {
    /**
     * オプションを元に正規表現オプジェクトを生成する
     * @param {Array} opt `space` オプション
     * @param {boolean} btwHanAndZen=true 半角全角の間か全角半角の間か
     * @returns {Object}
     */
    var generateRegExp = function generateRegExp(opt) {
      var btwHanAndZen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var alphabets = opt.alphabets ? "A-Za-z" : "";
      var numbers = opt.numbers ? "0-9" : "";
      var expStr;
      if (btwHanAndZen) {
        expStr = "([".concat(alphabets).concat(numbers, "])(?:").concat(ZenRegExpStr, ")");
      } else {
        expStr = "(".concat(ZenRegExpStr, ")[").concat(alphabets).concat(numbers, "]");
      }
      return new RegExp(expStr);
    };
    var betweenHanAndZenRegExp = generateRegExp(options);
    var betweenZenAndHanRegExp = generateRegExp(options, false);
    var errorMsg = "原則として、全角文字と半角文字の間にスペースを入れます。";
    var betweenHanAndZen = (0, _matchIndex.matchCaptureGroupAll)(text, betweenHanAndZenRegExp);
    var betweenZenAndHan = (0, _matchIndex.matchCaptureGroupAll)(text, betweenZenAndHanRegExp);
    var reportMatch = match => {
      var {
        index
      } = match;
      report(node, new RuleError(errorMsg, {
        index: match.index,
        fix: fixer.replaceTextRange([index + 1, index + 1], " ")
      }));
    };
    betweenHanAndZen.filter(createFilter(text, 1)).forEach(reportMatch);
    betweenZenAndHan.filter(createFilter(text, 0)).forEach(reportMatch);
  };
  return {
    [Syntax.Str](node) {
      if (!lintStyledNode && !helper.isPlainStrNode(node)) {
        return;
      }
      var text = getSource(node);
      var noSpace = key => key === "punctuation" ? true : !spaceOption[key];
      if (Object.keys(spaceOption).every(noSpace)) {
        noSpaceBetween(node, text);
      } else {
        needSpaceBetween(node, text, spaceOption);
      }
    }
  };
}
module.exports = {
  linter: reporter,
  fixer: reporter
};
//# sourceMappingURL=index.js.map